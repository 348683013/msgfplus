/***************************************************************************
 * Title:
 * Author:         Sangtae Kim
 * Last modified:
 *
 * Copyright (c) 2008-2009 The Regents of the University of California
 * All Rights Reserved
 * See file LICENSE for details.
 ***************************************************************************/
package edu.ucsd.msjava.msutil;

import edu.ucsd.msjava.params.ParamObject;
import edu.ucsd.msjava.params.UserParam;

import java.io.File;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;

/**
 * This class represents an enzyme.
 *
 * @author sangtaekim
 */
public class Enzyme implements ParamObject {

    /**
     * True if the enzyme cleaves n-terminal of the residue, otherwise false
     */
    private boolean isNTerm;

    /**
     * Name of the enzyme.
     */
    private String name;

    /**
     * Description
     */
    private String description;

    /**
     * Amino acid residues cleaved by the enzyme.
     */
    private char[] residues;

    /**
     * Tracks whether a residue is cleavable
     * Residue symbols as chars are converted to their ASCII value when updating this array
     * For example, the cleavability of residue K is tracked at isResidueCleavable[82]
     */
    private boolean[] isResidueCleavable;

    // the probability that a peptide generated by this enzyme follows the cleavage rule
    // E.g. for trypsin, probability that a peptide ends with K or R
    private float peptideCleavageEfficiency = 0;

    // the probability that a neighboring amino acid follows the enzyme rule
    // E.g. for trypsin, probability that the preceding amino acid is K or R
    private float neighboringAACleavageEfficiency = 0;

    private String psiCvAccession;

    /**
     * Instantiates a new enzyme.
     *
     * @param name     the name
     * @param residues the residues cleaved by the enzyme (String)
     * @param isNTerm  N term or C term (true if it cleaves N-term)
     */
    private Enzyme(String name, String residues, boolean isNTerm, String description, String psiCvAccession) {
        this.name = name;
        this.description = description;

        /*
         * null is passed as the residue string for both non-specific and
         * "no cleavage", so in order to distinguish the desired behavior we
         * inspect the controlled vocabulary name of the enzyme to determine
         * if it is "no cleavage"
         *
         */
        if (psiCvAccession != null && psiCvAccession.equals("MS:1001955")) {
            // NoCleavage aka no internal cleavage
            this.residues = new char[0];
            this.isResidueCleavable = new boolean[128];
        } else if (residues != null) {
            this.residues = new char[residues.length()];
            this.isResidueCleavable = new boolean[128];
            for (int i = 0; i < residues.length(); i++) {
                char residue = residues.charAt(i);
                if (!Character.isUpperCase(residue)) {
                    System.err.println("Enzyme residues must be uppercase: " + residue);
                    System.exit(-1);
                }
                this.residues[i] = residue;
                isResidueCleavable[residue] = true;
            }
        }
        this.isNTerm = isNTerm;
        this.psiCvAccession = psiCvAccession;
    }

    public static void loadCustomEnzymeFile(File enzymeFile) {

        customEnzymeFilePath = enzymeFile.getAbsolutePath();

        // Uncomment to debug
        // System.out.println("Loading user-defined enzyme file: " + customEnzymeFilePath);

        int tokenLength = 4;
        ArrayList<String> paramLines = UserParam.parseFromFile(enzymeFile.getPath(), tokenLength);
        for (String paramLine : paramLines) {
            String[] token = paramLine.split(",", tokenLength);
            String shortName = token[0];
            String cleaveAt = token[1];
            if (cleaveAt.equalsIgnoreCase("null"))
                cleaveAt = null;
            else {
                for (int i = 0; i < cleaveAt.length(); i++) {
                    if (!AminoAcid.isStdAminoAcid(cleaveAt.charAt(i))) {
                        System.err.println("Invalid user-defined enzyme at " + enzymeFile.getAbsolutePath() + ": " + paramLine);
                        System.err.println("Unrecognizable amino acid residue: " + cleaveAt.charAt(i));
                        System.exit(-1);
                    }
                }
            }
            boolean isNTerm = false;    // C-Term: false, N-term: true
            if (token[2].equals("C"))
                isNTerm = false;
            else if (token[2].equals("N"))
                isNTerm = true;
            else {
                System.err.println("Invalid user-defined enzyme at " + enzymeFile.getAbsolutePath() + ": " + paramLine);
                System.err.println(token[2] + " must be 'C' or 'N' for C-terminal or N-terminal");
                System.exit(-1);
            }

            String description;
            int commentCharIndex = token[3].indexOf('#');
            if (commentCharIndex > 0)
                description = token[3].substring(0, commentCharIndex).trim();
            else
                description = token[3].trim();

            Enzyme userEnzyme = new Enzyme(shortName, cleaveAt, isNTerm, description, null);
            register(shortName, userEnzyme, true);
        }
    }

    /**
     * Sets the neighboring amino acid efficiency as the probability that a neighboring amino acid follows the enzyme rule
     *
     * @param neighboringAACleavageEfficiency neighboring amino acid efficiency
     * @return this object
     */
    private void setNeighboringAAEfficiency(float neighboringAACleavageEfficiency) {
        this.neighboringAACleavageEfficiency = neighboringAACleavageEfficiency;
    }

    /**
     * Gets the neighboring amino acid efficiency
     * Deprecated, use getNeighboringAACleavageEfficiency
     *
     * @return neighboring amino acid efficiency
     */
    @Deprecated()
    public float getNeighboringAACleavageEffiency() {
        return getNeighboringAACleavageEfficiency();
    }

    /**
     * Gets the neighboring amino acid efficiency
     *
     * @return neighboring amino acid efficiency
     */
    public float getNeighboringAACleavageEfficiency() {
        return neighboringAACleavageEfficiency;
    }

    /**
     * Sets the peptide cleavage efficiency as the probability that a peptide generated by this enzyme follows the cleavage rule
     *
     * @param peptideCleavageEfficiency peptide cleavage efficiency
     * @return this object
     */
    private void setPeptideCleavageEfficiency(float peptideCleavageEfficiency) {
        this.peptideCleavageEfficiency = peptideCleavageEfficiency;
    }

    /**
     * Gets the peptide efficiency.
     *
     * @return peptide efficiency
     */
    public float getPeptideCleavageEfficiency() {
        return peptideCleavageEfficiency;
    }

    /**
     * Returns the name of the enzyme.
     *
     * @return the name of the enzyme.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the description of the enzyme.
     *
     * @return the description of the enzyme.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns the description of the enzyme when it is showed in the usage info.
     *
     * @return the description of the enzyme when it is showed in the usage info.
     */
    public String getParamDescription() {
        return description;
    }

    /**
     * Checks if this enzyme cleaves N term.
     *
     * @return true, if it cleaves N term.
     */
    public boolean isNTerm() {
        return isNTerm;
    }

    /**
     * Checks if this enzyme cleaves C term.
     *
     * @return true, if it cleaves C term.
     */
    public boolean isCTerm() {
        return !isNTerm;
    }

    /**
     * Checks if the amino acid is cleavable.
     *
     * @param aa the amino acid
     * @return true, if aa is cleavable
     */
    public boolean isCleavable(AminoAcid aa) {
        if (this.residues == null)
            return true;
        for (char r : this.residues)
            if (r == aa.getUnmodResidue())
                return true;
        return false;
    }

    /**
     * Checks if the amino acid is cleavable.
     *
     * @param residue amino acid residue
     * @return true, if residue is cleavable
     */
    public boolean isCleavable(char residue) {
        if (isResidueCleavable == null)
            return true;
        return isResidueCleavable[residue];
    }

    /**
     * Checks if the peptide is cleaved by the enzyme.
     * Does not check for exception residues (meaning K.P or K.P is considered cleavable for trypsin)
     *
     * @param p peptide
     * @return true if p is cleaved, false otherwise.
     */
    public boolean isCleaved(Peptide p) {
        AminoAcid aa;
        if (isNTerm)
            aa = p.get(0);
        else
            aa = p.get(p.size() - 1);
        return isCleavable(aa.getResidue());
    }

    /**
     * Returns PSI CV accession.
     *
     * @return HUPO PSI CV accession of this enzyme. null if unknown.
     */
    public String getPSICvAccession() {
        return this.psiCvAccession;
    }

    /**
     * Returns the number of cleavable terminii
     *
     * @param annotation annotation (e.g. K.DLFGEK.I)
     * @return the number of cleavable terminii
     */
    public int getNumCleavedTermini(String annotation, AminoAcidSet aaSet) {
        int nCT = 0;
        String pepStr = annotation.substring(annotation.indexOf('.') + 1, annotation.lastIndexOf('.'));
        Peptide peptide = aaSet.getPeptide(pepStr);

        // Check whether the C-terminus of the peptide is a cleavage point
        if (this.isCleaved(peptide))
            nCT++;

        if (this.isNTerm) {
            // N-terminal cleavage, including AspN
            AminoAcid nextAA = aaSet.getAminoAcid(annotation.charAt(annotation.length() - 1));
            if (nextAA == null || this.isCleavable(nextAA))
                nCT++;
        } else {
            // C-terminal cleavage, including trypsin
            AminoAcid precedingAA = aaSet.getAminoAcid(annotation.charAt(0));
            if (precedingAA == null || this.isCleavable(precedingAA))
                nCT++;
        }

        return nCT;
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    /**
     * Gets the residues.
     *
     * @return the residues
     */
    public char[] getResidues() {
        return residues;
    }

    /**
     * Unspecific cleavage enzyme (can cleavage after any residue)
     */
    public static final Enzyme UnspecificCleavage;

    /**
     * TRYPSIN enzyme (cleave after K or R)
     */
    public static final Enzyme TRYPSIN;

    /**
     * CHYMOTRYPSIN enzyme (cleave after FYWL)
     */
    public static final Enzyme CHYMOTRYPSIN;

    /**
     * LysC enzyme (cleave after K)
     */
    public static final Enzyme LysC;

    /**
     * LysN enzyme (cleave before K)
     */
    public static final Enzyme LysN;

    /**
     * GluC enzyme (cleave after E)
     */
    public static final Enzyme GluC;

    /**
     * ArgC enzyme (cleave after R)
     */
    public static final Enzyme ArgC;

    /**
     * AspN enzyme (cleave before D)
     */
    public static final Enzyme AspN;

    /**
     * ALP enzyme
     */
    public static final Enzyme ALP;

    /**
     * Endogenous peptides (do not cleave after any residue, i.e. no internal cleavage)
     */
    public static final Enzyme NoCleavage;

    /**
     * Custom enzyme file path
     * @return
     */
    public static String getCustomEnzymeFilePath() { return customEnzymeFilePath; }

    /**
     * Messages associated with enzymes loaded from the custom enzyme file
     * @return
     */
    public static ArrayList<String> getCustomEnzymeMessages() { return customEnzymeMessages; }

    /**
     * Get an Enzyme by enzyme name
     */
    public static Enzyme getEnzymeByName(String name) {
        return enzymeTable.get(name);
    }

    /**
     * Get all registered enzymes
     */
    public static Enzyme[] getAllRegisteredEnzymes() {
        return registeredEnzymeList.toArray(new Enzyme[0]);
    }

    /**
     * Obsolete method; does nothing
     */
    @Deprecated
    public static Enzyme register(String name, String residues, boolean isNTerm, String description) {
        return null;
    }

    private static HashMap<String, Enzyme> enzymeTable;
    private static ArrayList<Enzyme> registeredEnzymeList;

    private static String customEnzymeFilePath;
    private static ArrayList<String> customEnzymeMessages;

    private static void register(String name, Enzyme enzyme) {
        register(name, enzyme, false);
    }

    private static void register(String name, Enzyme enzyme, boolean notifyNewEnzyme) {
        if (enzymeTable.put(name, enzyme) == null) {
            // New enzyme name; add it to the registered enzyme list
            registeredEnzymeList.add(enzyme);
            if (notifyNewEnzyme) {
                customEnzymeMessages.add("Added new enzyme " + enzyme.name + " with target residues " + new String(enzyme.getResidues()));
            }
        } else {
            // Check for the user overriding the target residues or the description
            int targetIndex = -1;

            for (int enzymeIndex = 0; enzymeIndex < registeredEnzymeList.size(); enzymeIndex++) {
                Enzyme existingEnzyme = registeredEnzymeList.get(enzymeIndex);

                if (existingEnzyme.name.equals(enzyme.name)) {
                    String existingResidues = new String(existingEnzyme.residues);
                    String newResidues = new String(enzyme.residues);

                    if (!existingResidues.equals(newResidues)) {
                        customEnzymeMessages.add("Target residues for enzyme " + enzyme.name + " changed from " + existingResidues + " to " + newResidues);
                        targetIndex = enzymeIndex;
                        break;
                    }

                    if (!existingEnzyme.description.equalsIgnoreCase(enzyme.description)) {
                        targetIndex = enzymeIndex;
                        break;
                    }
                }
            }

            if (targetIndex >= 0) {
                registeredEnzymeList.set(targetIndex, enzyme);
            }
        }
    }

    static {
        UnspecificCleavage = new Enzyme("UnspecificCleavage", null, false, "unspecific cleavage", "MS:1001956");
        TRYPSIN = new Enzyme("Tryp", "KR", false, "Trypsin", "MS:1001251");
//		TRYPSIN.setNeighboringAAEfficiency(0.9148273f);
//		TRYPSIN.setPeptideCleavageEfficiency(0.98173124f);

//		TRYPSIN.setNeighboringAAEfficiency(0.9523f);
//		TRYPSIN.setPeptideCleavageEfficiency(0.9742f);

        // Modified by Sangtae to boost the performance
        TRYPSIN.setNeighboringAAEfficiency(0.99999f);
        TRYPSIN.setPeptideCleavageEfficiency(0.99999f);

        CHYMOTRYPSIN = new Enzyme("Chymotrypsin", "FYWL", false, "Chymotrypsin", "MS:1001306");

        LysC = new Enzyme("LysC", "K", false, "Lys-C", "MS:1001309");
//		LysC.setNeighboringAAEfficiency(0.79f);
//		LysC.setPeptideCleavageEfficiency(0.89f);
        LysC.setNeighboringAAEfficiency(0.999f);
        LysC.setPeptideCleavageEfficiency(0.999f);

        LysN = new Enzyme("LysN", "K", true, "Lys-N", null);
        LysN.setNeighboringAAEfficiency(0.79f);
        LysN.setPeptideCleavageEfficiency(0.89f);

        GluC = new Enzyme("GluC", "E", false, "glutamyl endopeptidase", "MS:1001917");
        ArgC = new Enzyme("ArgC", "R", false, "Arg-C", "MS:1001303");
        AspN = new Enzyme("AspN", "D", true, "Asp-N", "MS:1001304");

        ALP = new Enzyme("aLP", null, false, "alphaLP", null);

        // NoCleavage aka no internal cleavage
        // Do not allow cleavage after any residue
        NoCleavage = new Enzyme("NoCleavage", null, false, "no cleavage", "MS:1001955");

        enzymeTable = new HashMap<String, Enzyme>();
        registeredEnzymeList = new ArrayList<Enzyme>();

        // Add "UnspecificCleavage" to registeredEnzymeList
        // but do not call register to put it in the HashMap enzymeTable
        registeredEnzymeList.add(UnspecificCleavage); // 0

	    // Skip (see above): register(UnspecificCleavage.name, UnspecificCleavage);
        register(TRYPSIN.name, TRYPSIN);              // 1
        register(CHYMOTRYPSIN.name, CHYMOTRYPSIN);    // 2
        register(LysC.name, LysC);                    // 3
        register(LysN.name, LysN);                    // 4
        register(GluC.name, GluC);                    // 5
        register(ArgC.name, ArgC);                    // 6
        register(AspN.name, AspN);                    // 7
        register(ALP.name, ALP);                      // 8
        register(NoCleavage.name, NoCleavage);        // 9

        customEnzymeFilePath = "";
        customEnzymeMessages  = new ArrayList<String>();

        // Add user-defined enzymes
        // look for file enzymes.txt in the params directory below the working directory
        File enzymeFile = Paths.get("params", "enzymes.txt").toFile();

        // Uncomment to debug
        // System.out.println("Looking for user-defined enzyme file at " + enzymeFile.getAbsolutePath());

        if (enzymeFile.exists()) {
            loadCustomEnzymeFile(enzymeFile);
        }
    }
}
